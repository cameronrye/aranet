# Release workflow powered by cargo-dist
# This workflow builds and publishes release artifacts when a tag is pushed.
#
# To release:
#   1. Update version in Cargo.toml files
#   2. Commit: git commit -am "chore: release v0.1.0"
#   3. Tag: git tag v0.1.0
#   4. Push: git push origin main --tags
#
# cargo-dist will:
#   - Build binaries for all platforms
#   - Create GitHub Release with artifacts
#   - Generate shell/PowerShell install scripts
#   - Update Homebrew formula in tap repo

name: Release

permissions:
  contents: write

on:
  push:
    tags:
      - 'v[0-9]+.*'
  pull_request:
    paths:
      - '.github/workflows/release.yml'
      - 'Cargo.toml'
      - 'crates/*/Cargo.toml'

env:
  CARGO_TERM_COLOR: always

jobs:
  # Create the GitHub Release and upload global artifacts
  plan:
    runs-on: ubuntu-latest
    outputs:
      has-releases: ${{ steps.plan.outputs.has-releases }}
      releases: ${{ steps.plan.outputs.releases }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install cargo-dist
        run: |
          curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.sh | sh

      - name: Run cargo-dist plan
        id: plan
        run: |
          cargo dist plan --tag="${{ github.ref_name }}" --output-format=json > plan.json
          echo "has-releases=$(jq -r '.releases | length > 0' plan.json)" >> $GITHUB_OUTPUT
          echo "releases=$(jq -c '.releases' plan.json)" >> $GITHUB_OUTPUT
          cat plan.json

  # Build for each platform
  build:
    needs: plan
    if: needs.plan.outputs.has-releases == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: aarch64-apple-darwin
            os: macos-14
          - target: x86_64-apple-darwin
            os: macos-15-large
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-22.04
          - target: x86_64-pc-windows-msvc
            os: windows-2022
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install system dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libdbus-1-dev \
            libclang-dev \
            libgtk-3-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            libxkbcommon-dev \
            libxdo-dev \
            libssl-dev \
            pkg-config

      - name: Install cross-compilation tools (Linux ARM64)
        if: matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
          echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: "1.90"
          targets: ${{ matrix.target }}

      - name: Install cargo-dist (Unix)
        if: runner.os != 'Windows'
        run: |
          curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.sh | sh

      - name: Install cargo-dist (Windows)
        if: runner.os == 'Windows'
        run: |
          irm https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.ps1 | iex

      - name: Build artifacts
        run: cargo dist build --tag="${{ github.ref_name }}" --target="${{ matrix.target }}"

      # Build native app bundle for GUI (macOS .app, Windows .exe with resources)
      - name: Install cargo-bundle (Unix)
        if: runner.os != 'Windows'
        run: cargo install cargo-bundle

      - name: Install cargo-bundle (Windows)
        if: runner.os == 'Windows'
        run: cargo install cargo-bundle

      - name: Build macOS app bundle
        if: runner.os == 'macOS'
        run: |
          # Build the GUI app bundle
          cargo bundle --release --package aranet-gui --target ${{ matrix.target }}

          # Find and display the app bundle
          APP_BUNDLE=$(find target -name "Aranet.app" -type d | head -1)
          if [ -n "$APP_BUNDLE" ]; then
            echo "App bundle created at: $APP_BUNDLE"
            ls -la "$APP_BUNDLE"

            # Add icon to Resources (cargo-bundle doesn't always include it)
            mkdir -p "$APP_BUNDLE/Contents/Resources"
            cp assets/aranet-icon.icns "$APP_BUNDLE/Contents/Resources/aranet-gui.icns"

            # Add CFBundleIconFile to Info.plist if not present
            if ! grep -q "CFBundleIconFile" "$APP_BUNDLE/Contents/Info.plist"; then
              /usr/libexec/PlistBuddy -c "Add :CFBundleIconFile string aranet-gui" "$APP_BUNDLE/Contents/Info.plist"
            fi

            # Add Bluetooth usage descriptions (required by macOS TCC)
            # NSBluetoothAlwaysUsageDescription - required for macOS 11.0+
            if ! grep -q "NSBluetoothAlwaysUsageDescription" "$APP_BUNDLE/Contents/Info.plist"; then
              /usr/libexec/PlistBuddy -c "Add :NSBluetoothAlwaysUsageDescription string 'Aranet uses Bluetooth to discover and connect to your Aranet environmental sensors.'" "$APP_BUNDLE/Contents/Info.plist"
            fi
            # NSBluetoothPeripheralUsageDescription - for backward compatibility with older macOS
            if ! grep -q "NSBluetoothPeripheralUsageDescription" "$APP_BUNDLE/Contents/Info.plist"; then
              /usr/libexec/PlistBuddy -c "Add :NSBluetoothPeripheralUsageDescription string 'Aranet uses Bluetooth to discover and connect to your Aranet environmental sensors.'" "$APP_BUNDLE/Contents/Info.plist"
            fi

            echo "App bundle contents:"
            ls -la "$APP_BUNDLE/Contents/Resources/"

            # Create a DMG for distribution
            DMG_NAME="Aranet-${{ matrix.target }}.dmg"

            # Create a temporary directory for the DMG contents
            DMG_DIR=$RUNNER_TEMP/dmg
            mkdir -p "$DMG_DIR"
            cp -R "$APP_BUNDLE" "$DMG_DIR/"

            # Create Applications symlink for drag-and-drop install
            ln -s /Applications "$DMG_DIR/Applications"

            # Create the DMG
            hdiutil create -volname "Aranet" -srcfolder "$DMG_DIR" -ov -format UDZO "target/distrib/$DMG_NAME"

            echo "Created DMG: target/distrib/$DMG_NAME"
            ls -la target/distrib/
          else
            echo "Warning: App bundle not found"
          fi

      - name: Build Windows app bundle
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Note: cargo bundle doesn't support Windows .exe bundles
          # The GUI binary is already built by cargo dist, just copy it
          $exe = Get-ChildItem -Path "target/${{ matrix.target }}/release" -Filter "aranet-gui.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($exe) {
            Write-Host "Found GUI binary: $($exe.FullName)"
            # Copy to distrib folder
            $distDir = "target/distrib"
            if (-not (Test-Path $distDir)) {
              New-Item -ItemType Directory -Path $distDir -Force | Out-Null
            }
            Copy-Item $exe.FullName -Destination "$distDir/aranet-gui-${{ matrix.target }}.exe"
            Write-Host "Copied to: $distDir/aranet-gui-${{ matrix.target }}.exe"
          } else {
            Write-Host "GUI binary not found in target/${{ matrix.target }}/release, checking distrib..."
            # It may already be in distrib from cargo dist
            $existing = Get-ChildItem -Path "target/distrib" -Filter "aranet-gui*" -ErrorAction SilentlyContinue
            if ($existing) {
              Write-Host "Found in distrib: $($existing.Name)"
            } else {
              Write-Host "No GUI binary found - this is expected if aranet-gui is not built on Windows"
            }
          }

      # Apple code signing and notarization for macOS
      - name: Import Apple certificate
        if: runner.os == 'macOS' && startsWith(github.ref, 'refs/tags/')
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          if [ -z "$APPLE_CERTIFICATE" ]; then
            echo "APPLE_CERTIFICATE not set, skipping code signing"
            exit 0
          fi

          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          echo "$APPLE_CERTIFICATE" | base64 --decode > $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"

          # Allow codesign to access the key
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "Certificate imported successfully"

      - name: Sign macOS binaries and app bundle
        if: runner.os == 'macOS' && startsWith(github.ref, 'refs/tags/')
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          if [ -z "$APPLE_CERTIFICATE" ]; then
            echo "Skipping code signing (no certificate)"
            exit 0
          fi

          SIGNING_IDENTITY="Developer ID Application: Cameron Rye ($APPLE_TEAM_ID)"
          echo "Contents of target/distrib:"
          ls -la target/distrib/

          # === Sign CLI binary in tarball ===
          TARBALL=$(find target/distrib -name "aranet-cli-*.tar.xz" | head -1)
          if [ -z "$TARBALL" ]; then
            echo "No aranet-cli tarball found, checking for any tarball..."
            TARBALL=$(find target/distrib -name "*.tar.xz" | head -1)
          fi

          if [ -n "$TARBALL" ]; then
            echo "Found tarball: $TARBALL"

            # Extract the tarball
            EXTRACT_DIR=$RUNNER_TEMP/extract
            mkdir -p "$EXTRACT_DIR"
            tar -xJf "$TARBALL" -C "$EXTRACT_DIR"

            echo "Extracted contents:"
            find "$EXTRACT_DIR" -type f

            # Find and sign the CLI binary
            BINARY_PATH=$(find "$EXTRACT_DIR" -name "aranet" -type f | head -1)
            if [ -n "$BINARY_PATH" ]; then
              echo "Signing CLI binary at: $BINARY_PATH"
              codesign --force --options runtime --sign "$SIGNING_IDENTITY" --timestamp "$BINARY_PATH"
              codesign -dv --verbose=4 "$BINARY_PATH"

              # Re-package the signed binary
              TARBALL_NAME=$(basename "$TARBALL")
              rm "$TARBALL"
              tar -cJf "target/distrib/$TARBALL_NAME" -C "$EXTRACT_DIR" .
              echo "Re-packaged signed CLI binary into $TARBALL_NAME"
            else
              echo "Warning: CLI binary 'aranet' not found in tarball"
            fi
          else
            echo "No CLI tarball found in target/distrib"
          fi

          # === Sign the .app bundle and re-create DMG ===
          DMG_PATH=$(find target/distrib -name "Aranet-*.dmg" | head -1)
          if [ -n "$DMG_PATH" ]; then
            echo "Found DMG: $DMG_PATH"

            # Mount the DMG to sign the app inside
            MOUNT_DIR=$RUNNER_TEMP/dmg_mount
            mkdir -p "$MOUNT_DIR"
            hdiutil attach "$DMG_PATH" -mountpoint "$MOUNT_DIR" -nobrowse

            # Find the app bundle
            APP_BUNDLE=$(find "$MOUNT_DIR" -name "*.app" -type d | head -1)
            if [ -n "$APP_BUNDLE" ]; then
              # Copy app to a writable location for signing
              SIGN_DIR=$RUNNER_TEMP/sign_app
              mkdir -p "$SIGN_DIR"
              cp -R "$APP_BUNDLE" "$SIGN_DIR/"

              hdiutil detach "$MOUNT_DIR"

              SIGNED_APP="$SIGN_DIR/$(basename "$APP_BUNDLE")"

              # Copy entitlements file to the signing location
              ENTITLEMENTS_PATH="crates/aranet-gui/entitlements.plist"

              # Sign the app bundle with entitlements (deep signs all nested code)
              echo "Signing app bundle: $SIGNED_APP"
              echo "Using entitlements: $ENTITLEMENTS_PATH"
              codesign --force --deep --options runtime --entitlements "$ENTITLEMENTS_PATH" --sign "$SIGNING_IDENTITY" --timestamp "$SIGNED_APP"
              codesign -dv --verbose=4 "$SIGNED_APP"

              # Re-create the DMG with signed app
              DMG_NAME=$(basename "$DMG_PATH")
              rm "$DMG_PATH"

              DMG_CONTENTS=$RUNNER_TEMP/dmg_contents
              mkdir -p "$DMG_CONTENTS"
              cp -R "$SIGNED_APP" "$DMG_CONTENTS/"
              ln -s /Applications "$DMG_CONTENTS/Applications"

              hdiutil create -volname "Aranet" -srcfolder "$DMG_CONTENTS" -ov -format UDZO "target/distrib/$DMG_NAME"
              echo "Re-created signed DMG: target/distrib/$DMG_NAME"
            else
              hdiutil detach "$MOUNT_DIR" || true
              echo "Warning: No .app found in DMG"
            fi
          else
            echo "No DMG found to sign"
          fi

      - name: Notarize macOS binaries and app bundle
        if: runner.os == 'macOS' && startsWith(github.ref, 'refs/tags/')
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APP_STORE_CONNECT_KEY: ${{ secrets.APP_STORE_CONNECT_KEY }}
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          if [ -z "$APPLE_CERTIFICATE" ] || [ -z "$APP_STORE_CONNECT_KEY" ]; then
            echo "Skipping notarization (missing credentials)"
            exit 0
          fi

          # Write the API key to a file (shared for all submissions)
          mkdir -p $RUNNER_TEMP/private_keys
          echo "$APP_STORE_CONNECT_KEY" > $RUNNER_TEMP/private_keys/AuthKey_${APP_STORE_CONNECT_KEY_ID}.p8
          API_KEY_PATH="$RUNNER_TEMP/private_keys/AuthKey_${APP_STORE_CONNECT_KEY_ID}.p8"

          # === Notarize CLI binary ===
          TARBALL=$(find target/distrib -name "aranet-cli-*.tar.xz" | head -1)
          if [ -z "$TARBALL" ]; then
            TARBALL=$(find target/distrib -name "*.tar.xz" | head -1)
          fi

          if [ -n "$TARBALL" ]; then
            echo "Notarizing CLI from tarball: $TARBALL"
            EXTRACT_DIR=$RUNNER_TEMP/notarize_cli
            mkdir -p "$EXTRACT_DIR"
            tar -xJf "$TARBALL" -C "$EXTRACT_DIR"
            BINARY_PATH=$(find "$EXTRACT_DIR" -name "aranet" -type f | head -1)

            if [ -n "$BINARY_PATH" ]; then
              ZIP_PATH=$RUNNER_TEMP/aranet-cli-notarize.zip
              ditto -c -k --keepParent "$BINARY_PATH" "$ZIP_PATH"

              echo "Submitting CLI binary for notarization..."
              xcrun notarytool submit "$ZIP_PATH" \
                --key "$API_KEY_PATH" \
                --key-id "$APP_STORE_CONNECT_KEY_ID" \
                --issuer "$APP_STORE_CONNECT_ISSUER_ID" \
                --wait
              echo "CLI binary notarization complete"
            else
              echo "Warning: CLI binary not found in tarball"
            fi
          else
            echo "No CLI tarball found to notarize"
          fi

          # === Notarize DMG (contains .app bundle) ===
          DMG_PATH=$(find target/distrib -name "Aranet-*.dmg" | head -1)
          if [ -n "$DMG_PATH" ]; then
            echo "Submitting DMG for notarization: $DMG_PATH"
            xcrun notarytool submit "$DMG_PATH" \
              --key "$API_KEY_PATH" \
              --key-id "$APP_STORE_CONNECT_KEY_ID" \
              --issuer "$APP_STORE_CONNECT_ISSUER_ID" \
              --wait

            # Staple the notarization ticket to the DMG
            echo "Stapling notarization ticket to DMG..."
            xcrun stapler staple "$DMG_PATH"
            echo "DMG notarization and stapling complete"
          else
            echo "No DMG found to notarize"
          fi

          echo "All notarization complete"

      - name: Clean up keychain
        if: runner.os == 'macOS' && always()
        run: |
          if [ -n "$KEYCHAIN_PATH" ] && [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ matrix.target }}
          path: target/distrib/

  # Publish the release
  publish:
    needs: [plan, build]
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true

      - name: Install cargo-dist
        run: |
          curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.sh | sh

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cargo dist plan --tag="${{ github.ref_name }}" --output-format=json > plan.json

          # Create release notes from CHANGELOG if available
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"

          # List only top-level files in target/distrib (not files inside subdirectories)
          # These are the actual release artifacts (.tar.xz, .sha256, installer scripts, etc.)
          echo "Files to upload:"
          find target/distrib -maxdepth 1 -type f | head -20

          # Create the release with only top-level files (not extracted contents in subdirectories)
          gh release create "${{ github.ref_name }}" \
            --title "Aranet CLI ${{ github.ref_name }}" \
            --generate-notes \
            $(find target/distrib -maxdepth 1 -type f)

      - name: Update Homebrew tap
        if: success()
        env:
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          if [ -z "$HOMEBREW_TAP_TOKEN" ]; then
            echo "HOMEBREW_TAP_TOKEN not set, skipping Homebrew tap update"
            exit 0
          fi

          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"

          echo "Generating Homebrew formula and cask for version $VERSION"

          # Calculate SHA256 hashes for all artifacts
          cd target/distrib

          # CLI binaries (cargo-dist uses aranet-cli-* naming)
          SHA256_CLI_MACOS_ARM64=$(sha256sum aranet-cli-aarch64-apple-darwin.tar.xz 2>/dev/null | cut -d' ' -f1 || echo "")
          SHA256_CLI_MACOS_X64=$(sha256sum aranet-cli-x86_64-apple-darwin.tar.xz 2>/dev/null | cut -d' ' -f1 || echo "")
          SHA256_CLI_LINUX_X64=$(sha256sum aranet-cli-x86_64-unknown-linux-gnu.tar.xz 2>/dev/null | cut -d' ' -f1 || echo "")

          # GUI binaries (cargo-dist uses aranet-gui-* naming)
          SHA256_GUI_MACOS_ARM64=$(sha256sum aranet-gui-aarch64-apple-darwin.tar.xz 2>/dev/null | cut -d' ' -f1 || echo "")
          SHA256_GUI_MACOS_X64=$(sha256sum aranet-gui-x86_64-apple-darwin.tar.xz 2>/dev/null | cut -d' ' -f1 || echo "")
          SHA256_GUI_LINUX_X64=$(sha256sum aranet-gui-x86_64-unknown-linux-gnu.tar.xz 2>/dev/null | cut -d' ' -f1 || echo "")

          # DMG files for Cask
          SHA256_DMG_ARM64=$(sha256sum Aranet-aarch64-apple-darwin.dmg 2>/dev/null | cut -d' ' -f1 || echo "")
          SHA256_DMG_X64=$(sha256sum Aranet-x86_64-apple-darwin.dmg 2>/dev/null | cut -d' ' -f1 || echo "")

          cd $GITHUB_WORKSPACE

          echo "SHA256 hashes calculated:"
          echo "  CLI macOS ARM64: $SHA256_CLI_MACOS_ARM64"
          echo "  CLI macOS x64: $SHA256_CLI_MACOS_X64"
          echo "  CLI Linux x64: $SHA256_CLI_LINUX_X64"
          echo "  GUI macOS ARM64: $SHA256_GUI_MACOS_ARM64"
          echo "  GUI macOS x64: $SHA256_GUI_MACOS_X64"
          echo "  GUI Linux x64: $SHA256_GUI_LINUX_X64"
          echo "  DMG ARM64: $SHA256_DMG_ARM64"
          echo "  DMG x64: $SHA256_DMG_X64"

          # Clone the tap repo
          git clone https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/cameronrye/homebrew-aranet.git /tmp/homebrew-aranet

          # Generate Formula from template
          if [ -f ".github/homebrew/aranet.rb.template" ]; then
            sed -e "s/{{VERSION}}/$VERSION/g" \
                -e "s/{{SHA256_CLI_MACOS_ARM64}}/$SHA256_CLI_MACOS_ARM64/g" \
                -e "s/{{SHA256_CLI_MACOS_X64}}/$SHA256_CLI_MACOS_X64/g" \
                -e "s/{{SHA256_CLI_LINUX_X64}}/$SHA256_CLI_LINUX_X64/g" \
                -e "s/{{SHA256_GUI_MACOS_ARM64}}/$SHA256_GUI_MACOS_ARM64/g" \
                -e "s/{{SHA256_GUI_MACOS_X64}}/$SHA256_GUI_MACOS_X64/g" \
                -e "s/{{SHA256_GUI_LINUX_X64}}/$SHA256_GUI_LINUX_X64/g" \
                .github/homebrew/aranet.rb.template > /tmp/homebrew-aranet/Formula/aranet.rb
            echo "Generated Formula/aranet.rb"
          fi

          # Generate Cask from template
          if [ -f ".github/homebrew/aranet-gui.rb.template" ] && [ -n "$SHA256_DMG_ARM64" ]; then
            mkdir -p /tmp/homebrew-aranet/Casks
            sed -e "s/{{VERSION}}/$VERSION/g" \
                -e "s/{{SHA256_DMG_ARM64}}/$SHA256_DMG_ARM64/g" \
                -e "s/{{SHA256_DMG_X64}}/$SHA256_DMG_X64/g" \
                .github/homebrew/aranet-gui.rb.template > /tmp/homebrew-aranet/Casks/aranet-gui.rb
            echo "Generated Casks/aranet-gui.rb"
          fi

          # Commit and push
          cd /tmp/homebrew-aranet
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Formula/ Casks/ 2>/dev/null || true
          git commit -m "Update aranet to ${{ github.ref_name }}" || echo "No changes to commit"
          git push origin main

          echo "Homebrew tap updated successfully"
